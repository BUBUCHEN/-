#include<iostream>
#include<vector>
using namespace std;
struct pair_s{//自製pair 
		int nxt;//下一個節點 
		int value;//權重 
};
struct node_struct{
	int now_value;
	int on_fire_t; 
	vector<pair_s> child;
	vector<pair_s> father; 
};
int s,e;
node_struct node[200];
void bfs_fire_out(int now,int t){
	if(node[now].on_fire_t<t){
		node[now].on_fire_t=t;
	}
	else{
		return ;
	}
	for(int i=0;i<node[now].child.size();i++){
		bfs_fire_out(node[now].child[i].nxt,t+node[now].child[i].value);
	}
	for(int i=0;i<node[now].father.size();i++){
		bfs_fire_out(node[now].father[i].nxt,t+node[now].father[i].value);
	}
}
void bfs(int now_pos,int now_value){
	if(now_value>=node[now_pos].now_value||now_value>node[now_pos].on_fire_t){
		return ;
	}
	else {
		node[now_pos].now_value=now_value;
	}
	for(int i=0;i<node[now_pos].child.size();i++){
		bfs(node[now_pos].child[i].nxt,now_value+node[now_pos].child[i].value);
	}
}
void back_tracking(int now_pos,string recode){
	recode+=now_pos+'0';
	if(now_pos==s){
		cout<<recode<<"\n";	
	}
	for(int i=0;i<node[now_pos].father.size();i++){
		if(node[now_pos].now_value-node[now_pos].father[i].value==node[node[now_pos].father[i].nxt].now_value){
			back_tracking(node[now_pos].father[i].nxt,recode);
		}
	}
}
int main(){
	pair_s tmp;
	/*
	輸入介紹:
	第一行一個數字n
	再來有n 行
	每 i 行第一個數字是 a_(i-1) 這個節點的子節點數 x  子節點編號由1~n 
	再來會有2x個數字 第一個代表子節點的編號，第二個數字代表權重
	最後會有兩個數字代表起點、終點 
	再來會有一個數字 o 代表有幾個點著火
	再來會有o行，代表著火的點的編號 
	*/
	
	int n,i,x,a,b,o,on_f;
	cin>>n;
	for(int i=1;i<=n;i++){
		cin>>x;
		node[i].now_value=99999;
		node[i].on_fire_t=9999;
		for(int c=0;c<x;c++){
			cin>>a>>b;
			tmp.nxt=a,tmp.value=b;
			node[i].child.push_back(tmp);
			tmp.nxt=i,tmp.value=b;
			node[a].father.push_back(tmp);	
		} 
	}
	string no="";
	cin>>s>>e;
	cin>>o;
	for(int k=0;k<o;k++){
		cin>>on_f;
		bfs_fire_out(on_f,0);
	}
	bfs(s,0);	 
	back_tracking(e,no);
} 
